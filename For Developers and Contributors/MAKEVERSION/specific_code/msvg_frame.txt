//START msvg FRAME
// msvg_210117.js
//
// javascript code for generation of a series subfolders, one for each SMILES-question, in the current directory.
// INPUT: a xxx_CDE.txt file as generated from the .csv export of Moodle by csv2cde.app
//        this file must reside inside the current diirectory
// OUTPUT:
// The subfolder for a particular question will contain:
// 1. a HTML file displaying the ungraded answers (not leer, 100% or xx%) with candidate name, SMILES and Strutural Formula
// 2. a statistics file listing all unique ungraded answers, the names of candidates that answered with this SMILES,
//    the frequency of occurrence of this answer, the structural formula, and the path to an svg file with this structural formula.
// 3. A subfolder "SVGs", containing all graphics files for the structural formulae in .svg format
//    The .svg graphics files inside the "SVGs" folders are generated by the parser of MOSFECCS_v5
//    and checked for identity with the input SMILES by getsmiles() of of MOSFECCS_v5
// 4. zz_xxxx.txt (tab separated, same format as CDE.txt) which lists candidate names and SMILES-strings for this question/partial-question
//    and is written as intermediate output. 
// 5. A LOG file _log_xxxxCDE.txt will be written on the level of the current directory. 
//    It first lists all candidates, which have given the same SMILES-answer to more than one question (copy/paste errors?)
//    Then, for each question, it lists the candidiates that gave answers that were automatically graded by Moodle
//    i.e. either 100%, partially correct xx%, or NO ANSWER (leer).


// USAGE:
//  Note: nodeJS must be installed on your Mac for this: check in terminal by entering: which node<return>. If empty string is returned, 
//  install nodeJS from: https://nodejs.org/en/
// 
//  In the terminal: Use cd to go to the directory containing the input xxxCDE.text file and this script (msvg_xxxxxx.js)
//  In the terminal, enter: node msvg_xxxxxx.js xxx_CDE.txt<return>

// NOTE: depending on the number of SMILES-questions in the exam and the number of candidates, execution of this script may require several seconds.

// December 2019 copyright B. Jaun, ETH Zurich

//MODIFICATIONS:
//  200112: BUG 200108.1 fixed -> getsmiles() replaced
//  200210: BUGS
//  200216: workover of drawAtomLabel_svg()
//  200227: BUGFIX 200227.1 included
//          passed through lebab->let->arrow->arrow-return, changed declaration of smnames to {}, key repl by ky in main
//          exchanged all functions except main and sub of main by functions from mostest_200226.js
//          changed main of parse_m_SMILES_svg sections from  mostest to msvg version
//  200301: changed all function except main and sub of main by functions of mostest_200301.js
//  201203: v6, redesign of sketcherframe, adaption to phones and MoodleMobileApp
//  210117: adaption to xxx-CDE.txt files for multi-exam (OCI&II, OCI and OCII) as generated by combineCDEs.pl


    "use strict";

  // MAIN msvg FUNCTION (IIFE)
  (function msvg() {
    const fs = require('fs');
    const path = require('path');
    
    // variables for msvg specific part
    const outdirlist = [];
    let svgwidth=[];
    let infile='';
    let base='';
    let outfile='';
    let outdir='';
    const insmiles='';
    let lines = [];
    let header = [];
    let answer='';
    const ans=[];
    const pick='';
    let matchcol=[];
    let asmiles='';
    let lf=[];
    let name='';
    const smnames={};
    let smfrq = [];
    let svglist=[];
    let namelist=[];
    let smlist=[];
    let resu=0;
    let parserr='';
    let pWarnAtoms=[];
    let smfail=[];
    let namfail=[];
    let smwarn=[];
    let namwarn=[];
    let smerr=[];
    let namerr=[];
    let statfile='';
    let statstr='';
    let a100=0;
    let apart=0;
    let aleer=0;
    let afail=0;
    let awarn=0;
    let aerr=0;
    let svg='';
    let i=0;
    let ii=0;
    let k=0;
    let j=0;
    let currentDate = new Date();
    let date = currentDate.getDate();
    const month = currentDate.getMonth(); 
    const year = currentDate.getFullYear(); 
    let time = currentDate.toTimeString();
    let logstr = '';
    let logfile = '';
    let htmlfile = '';
    const username = process.env.USER;
    const cwd = process.cwd();
    const cellW = 300;
    const cellH = 195;
    let errMsg = '';
    let ky;
    
  // variables from MOSFECCS_v5 drawCanvas() part    
  // pseudoconstants
        const version = "msvg_201212"
        const build = "201212.1"
        const emfuSmiles = true;  // use small letters for atoms in mancude rings for SMILES.

        //graphics constants      
        // not dependent on bondlength
        const dbratio = 24; // distance between lines of double bond expressed as ratio bondlength/distance
        const charW = 11;  // used to calculate length of text in px
        let charH = 10; // used to set font size and calculate height of text in px
        const charWs = 11;  // used to calculate length of text in px
        const charHs = 14; // used to set font size and calculate height of text in px

        let bondlength = 30;  // length of a bond in px. !! Can be changed by parse SMILES when structure is larger than drect
      
        // dependent on bondlength
        let crit = bondlength/5;  // critical distance for mouse from atoms
        let ofs = Math.round(150*bondlength/dbratio)/100;  // distance between lines of double bond in px
        let downlw = 6*ofs;  // linewidth for dashed wedges
        let stdlw = (bondlength > 30)? 2:1.5;  // linewidth of a single bond in px

        // chemical constants
        //  regexp for matching valid element symbols
        const resreg = /^R[1234]?$/g; // pattern characterizing allowed residue symbols R,R1,R2,R3,R4
        const residues = ["R","R1","R2","R3","R4"]; //allowed residue symbols R,R1,R2,R3,R4
        const sextets = ["C:","N:"]; // carbenes and nitrenes
        //  array of all element symbols as strings
        const elesym = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu"];
        //  normal valency of all elements in elesym[]. 0 stands for no normal valency defined
        const val = [0,1,0,0,0,3,4,3,2,1,0,0,0,3,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,3,2,1,0,1,2,0,0,0,0,0,0,0,0,1,2,3,4,3,2,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        const elpos = ["B","Al"]; // electropositive elements with hydride ligands
        const prim = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
              101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,
              233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,
              383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,
              547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,
              701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,
              877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013 ,1019,1021,1031,
              1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,
              1181,1187,1193,1201,1213,1217]; // primes from 1->2 to 200->1217
        const organic = ["B", "C", "N", "O", "P", "S", "F", "Cl", "Br", "I","Si"]; // the elements considered to be "organic"
        const emfuAtoms = ["B","C", "N", "O", "P", "S", "As", "Se"]; // elements that can be part of an EMFU-ring
        const emfuElesym = ["b","c", "n", "o", "p", "s", "as", "se"]; // symbol of emfu-Element in SMILES
        // strings characterizing the bonding situations for each element that is considered as possible stereogenic center. format: "ElementSymbol:number of ligands:number of implicit hydrogens:charge"
        const pSC = ["C:4:0:0","C:3:1:0","Si:4:0:0","Si:3:1:0","Ge:4:0:0","Ge:3:1:0","Sn:4:0:0","Sn:3:1:0","N:4:0:1","P:4:0:1","B:4:0:-1","B:3:1:-1","P:4:0:0","As:4:0:1","N:3:0:az","P:3:0:0","As:3:0:0","P:2:1:0","As:2:1:0","S:4:0:0","S:4:0:1","S:3:0:0","S:3:0:1","Se:4:0:0","Se:4:0:1","Se:3:0:0","Se:3:0:1"];
        // strings characterizing the bonding situation of potentially stereogenic (trigonal pyramidal) three-valent centers
        const pyrSC = ["N:3:0:az","P:3:0:0","P:2:1:0","As:3:0:0","As:2:1:0","S:3:0:0","S:3:0:1","Se:3:0:0","Se:3:0:1"]; // no implicit H at pyramidal stereocenters allowed

  // variables with "global" scope inside drawCanvas()

        // rectangles defining areas on canvas
        const arect = new Rect(0,0,1000,1000); // the drawing area as a rect
        let gb = new Rect(0,0,0,0);  // rect to contain the bounding rectangle of a drawn object (structure or tree)

        // MAIN DATA STRUCTURES
        // arrays of Atom objects
        const m = [new Atom(0, "", 0, 0, 0, 0, 0)]; // index 0 contains a dummy atom, the real atoms start with m[1]
        const m_s = [new Atom(0, "", 0, 0, 0, 0, 0)]; // shadow copy of m for smiles calculation (without explicit H), filled by genshadow()
        const m_s0 = [new Atom(0, "", 0, 0, 0, 0, 0)]; // temporary copy of m_s for ring detection via hidebond(), filled by genshadow()
        const m_st = [new Atom(0, "", 0, 0, 0, 0, 0)];  // temporary copy of m_s for substructure (tree) determination,filled by genshadow()
        let m4cc = [new Atom(0, "", 0, 0, 0, 0, 0)];  // used for storing cumulenes in get_ccSense_one(), reset in clearMol_svg(), filled by genshadow()
      
        // arrays of Bond objects
        const b = [new Bond(0,0,0)]; // index 0 contains a dummy bond, the real bonds start with b[1]
        const b_s = [new Bond(0,0,0)]; // shadow copy of m for smiles calculation (without explicit H) filled by genshadow()
        const b_s0 = [new Bond(0,0,0)]; // temporary copy of b_s for ring detection via hidebond() filled by genshadow()
        const b_st = [new Bond(0,0,0)]; // temporary copy of b_s for substructure (tree) determination filled by genshadow()
      
        // other arrays of data objects
        let lig = [new Branch(0,0)];
        let arro = []; //array storing the Arrow{} objects
        let arro_s = []; //shadow array of arrows for SMILES
        let rxnarro = []; // array storing Rxnarw{} objects
        let rxn_s = []; // shadow array of rxn arrows for SMILES
      
        // primitive variables used in SMILES Input und conversion
      
        //arrays used by functions in several sections: have to be in the drawCanvas scope
        let bisectors = []; // array containing the directions in Â° of the bisectors between all bonds at an atom //BF191115
        let bridgeheads = []; // array with atom indices of bridgeheads. Filled by findBridgeheads() !!used also by stereobonds()
        let ccSense = []; // pseudohash: key is string with atom index of central atom, value is @ or @@
        let cumulat = []; // array with the atom indices of all cumulene atoms  !! used in getsmiles() and parseSMILES()
        let ezCC = []; // array of cumulene objects containing even cumulenes !!used also by parseSMILES()
        let incoming = []; // array specifiying for each atom the "incoming" atom. index is parallel to m[]. Filled by dfsRC !!used also by flipBranch()
        let molgrp_brects = []; // the bounding rects of molgrps
        let pscCC = []; // array of potentially stereogenic cumulenes !!used also in smiles parsing
        let rcstr = []; // hash with the atom index as key and the ring closures string as value. Filled by dfsRC() !! used also by smiles parsing
        let ringatoms = []; // array containing atom indices off all atoms in rings. Filled by findRingBonds() !!used also in smiles parsing
        let ringbonds = []; // array of indices in b-type arrays. Filled in findRingBonds(), required by isSCcandidate,!! used by several sections
        let ringclosures = []; // array of strings xx:yy with xx and yy being atom indices of atoms in ring closure !!used by several sections
        let rings = [];  // 2D array. rings[ringnumber][index in ring]. Values are the atom indices !!used by several sections
        let sectors = []; // array of Sector{} objects containing the sectors between bonds around an atom !! used in several sections
        let smilesarray = []; // array of atom indices in the order from dfsSmiles !! used in several sections
        let visnodesDFS = []; // array of the nodes visited by dfs(). Values are atom indices !!used by several sections
        let warnAtoms = []; //!!used in getsmiles and parseSMILES: the atoms that will be shown with a red square
      
        // primitive variables
        let nmol = 0; // number of molecules (trees)
        let nRings = 0; // the number of rings. Calculated from the number of bonding partners of each atom by numRings()

      
         //variables required to remember things from one mouse event to the next one
        let permstodo = 1; // counter for permutations remaining to be done
        let permu = 1; // total permutations due to ties
        let rxnco = [];
        let smiles = "";  // the SMILES string

        // boolean variables and flags
        // alternators for provisional drawing      
        let hasStereo = false;
        let nolinedash = false;  // indicator for browsers that do not support linedash
      
        // variables for compatibility with mv5_xxx.js functions
        let showatnum = false; // flag used in diagnostic
        let showsymnum = false; // flag used in diagnostic
        let benzene = false; 

  // END of variable declarations

// MAIN CODE OF msvg()
//   console.log(process.env);
  console.log(intLeadingZero(date,2)+"." + intLeadingZero(month + 1,2) + "." + year+" "+time);
  console.log("msvg.js run with CDE file: "+process.argv[2]);
  logstr += "LOGFILE for msvg.js with CDE file: "+process.argv[2]+"\n";
  logstr += "run by "+username+" on node at ";
  logstr += intLeadingZero(date,2)+"." + intLeadingZero(month + 1,2) + "." + year+" "+time+"\n";
  logstr += "=========================================\n";  
  logstr += "\nMultiple identical answers to different questions\n__________________________\n\n";  
// Input: CDE text file 
  // Make sure we got a filename on the command line.
  if (process.argv.length === 3) {
    infile = process.argv[2];
    extractCDE(infile);
  } else {
    console.log('Usage: node ' + process.argv[1] + ' <CDE text filename>');
    return;
  }
  
  
  //read the input text files created per answer in createCDE() one by one

  for (ii=0; ii < outdirlist.length; ii++) { // loop over all answers
    infile='./'+outdirlist[ii]+'/zz_'+outdirlist[ii]+'.txt';

    try { 
      lines = fs.readFileSync(infile, 'utf8').toString().split("\n");
    } catch (err) {
      console.error(err);
    }

    header=lines[0].split('\t');
//     console.log("ii="+ii+" lines: "+lines.length+"\n\tlines[0]: "+lines[0]);
    if (header[0].includes('Name')) {
      answer = header[1].replace(/\s+/g,'_');
    }
    console.log(header[1]);
    logstr += "\n"+header[1]+"\n__________________\n";
    
    outdir=outdirlist[ii];

    // reset ii-loop variables 
    a100=0;
    apart=0;
    aleer=0;
    awarn=0;
    afail=0;
    smfail=[];
    namfail=[];
    smwarn=[];
    namwarn=[];
    aerr=0;
    smerr=[];
    namerr=[];

    svglist=[];
    namelist=[];
    svgwidth = [];
    smlist = [];
    smfrq = [];

    // reset statistics pseudohash
    for (ky in smnames) {
      if (smnames.hasOwnProperty(ky)) {
        delete smnames[ky];
      }
    }

  // PARSING, CHECKING and SVG WRITING
    for (i=1; i < lines.length; i++) {  // for each candidate
      name='';
      lf = lines[i].split('\t');
      if (lf.length > 1) {
        name = lf[0];
        
//        name = name.replace(/\s+/g,'_');
        asmiles=String(lf[1]).trim();
        if (name.includes('Richtige')) {
          name = '100_Prozent';
        }
      } else {
        continue;
      }
      // exempt answers 'leer', '100%', and partially correct graded answers (containing '.[Pn+]'), and answer fields containing na or nothing from parsing
      if (!((asmiles.includes('100%')) || (asmiles.includes('leer')) || (/\.\[P\d{1,2}\+\]/.test(asmiles)) || (/^na/.test(asmiles))|| (asmiles===''))) {

//PARSER IS CALLED HERE
        errMsg='';
        parserr=''; //BF200108.2
        
        try {
          resu=parse_m_SMILES_svg(asmiles); 
        }
        catch(err) { //errors caused in parse_m_SMILES by JS
          console.error(err);
          errMsg = 'error caught by JS: '+err;
          resu=-3;
        }
        if (parserr !== '') { //Error in parse_m_SMILES or parseSMILES()
          errMsg = parserr;
          resu = -3;
        }
        if ((resu===0) || (resu===-1)) {
          clearMol_svg();
  
          base = path.basename(infile);
          base = base.replace('.txt','');
          base = base.substr(3);
          if (name!=='') {
            outfile = './'+outdir+'/SVGs/'+name+'_'+base+'.svg';
          } 
 
          try {
            const data = fs.writeFileSync(outfile, svg)            
          } catch (err) {
            console.error(err)
          }
          svglist.push('SVGs/'+name+'_'+base+'.svg');
          namelist.push(name.replace(/_/g,' '));
          smlist.push(asmiles.trim());
          if (resu===-1) {
            afail++;
            smfail.push(asmiles);
            namfail.push(name);
          }
          // store names in pseudohash with key=SMILES for statistics
          if (!(name.includes('100_Prozent'))) { // exempt '100prozent' from statistics
            if (smnames[asmiles]!==undefined) {
                smnames[String(asmiles)].push(name);
            } else {
              smnames[String(asmiles)]=[name];          
            }
          }
        } else if (resu===-2) {
          awarn++;
          smwarn.push(asmiles);
          namwarn.push(name);
          clearMol_svg();
        } else if (resu===-3) {
          aerr++;
          smerr.push(asmiles);
          namerr.push(name);
          console.log("\tparsing ERROR with SMILES: "+asmiles+" entered by "+name+" as "+answer);
          console.log("\tERR: "+errMsg);
          logstr += name+": "+answer+" Parser ERROR for entered SMILES: "+asmiles+"\n";
          logstr += "\tERR: "+errMsg+"\n";
          clearMol_svg();
        }
      } else { // empty or automatically graded answers
        if (asmiles.includes('100%')) {
          logstr += name+' answered '+answer.replace('Antwort','Question')+' with 100%\n';
          a100++;
        } else if (asmiles.includes('leer')) {
          logstr += name+" "+answer.replace('Antwort','Question')+" NO ANSWER\n";
          aleer++;
        } else if (/\.\[P\d{1,2}\+\]/.test(asmiles)) {
          matchcol=asmiles.match(/\.\[P(\d{1,2})\+\]/);
          asmiles=matchcol[1]+'%';
          logstr += name+' answered '+answer.replace('Antwort','Question')+' with '+asmiles+"\n";
          apart++;
        }
      }
    }  // end loop over all lines (SMILES) 
      
    // collect statistics
    // copy smnames[] pseudohash into array of objects smfrq[] and sort it according to descending frequency of a SMILES
    for (const key in smnames ) {
      if (smnames.hasOwnProperty(key)) {
        smfrq.push({s: key, nar: smnames[key]});
      }
    }
    smfrq.sort((a, b) => b.nar.length - a.nar.length);
//     statstr= answer.replace('Antwort','Question')+'\nSMILES\tFrequencies\t[Names]\n\n';
    
    answer= answer.replace('Antwort','Question')+'\nNames\tFrequency\tSMILES\tSVG\turl\n';
    statstr = answer.replace('Teil','part');
    statstr += '\t\t\troot-path\t'+cwd+'/\n';
    for (j=0; j<smfrq.length;j++) {
        for (k=0;k < smfrq[j].nar.length;k++) {
          statstr += String(smfrq[j].nar[k])+', ';
        }
        statstr = (statstr.slice(0,-2))+'\t';
        statstr += String(smfrq[j].nar.length)+'\t';
        statstr += String(smfrq[j].s)+'\t\t';
        statstr += outdir+'/SVGs/'+String(smfrq[j].nar[0])+'_'+base+'.svg\n';
    }
    statstr += '\nAnswers graded 100%\t'+String(a100)+'\n';
    statstr += 'Answers graded partially correct\t'+String(apart)+'\n';
    statstr += 'No Answer\t'+String(aleer)+'\n';
    if (smerr.length+smfail.length+smwarn.length > 0) {
      logstr += "\nSUMMARY for  "+header[1]+"\n";
    }
    if (smerr.length > 0) {
      statstr += '\nAnswers leading to parser ERROR\t'+aerr+'\n';
      for (k=0; k<smerr.length;k++) {
        statstr += smerr[k]+'\t\t['+namerr[k]+']';
        if (k < smerr.length-1) {
          statstr += '\n';
        }
      }
      logstr += "Parser ERRORs: "+smerr.length+"\n";
    }
    if (smfail.length > 0) {
      statstr += '\nAnswers leading to parser fail\t'+afail+'\n';
      for (k=0; k<smfail.length;k++) {
        statstr += smfail[k]+'\t\t['+namfail[k]+']';
        if (k < smfail.length-1) {
          statstr += '\n';
        }
      }
      logstr += "Parser FAILUREs: "+smfail.length+"\n";
    }
    if (smwarn.length > 0) {
      statstr += '\nAnswers leading to parser warning\t'+awarn+'\n';
      for (k=0; k<smwarn.length;k++) {
        if (k < smwarn.length-1) {
          statstr += smwarn[k]+'\t\t['+namwarn[k]+']';
        }
        if (k < smwarn.length-1) {
          statstr += '\n';
        }
      }
      logstr += "ATOM WARNINGs: "+smwarn.length+"\n";
    }
    // write statistics file
    statfile = './'+outdir+'/'+' frequencies_'+base+'.txt';
    try {
      const data = fs.writeFileSync(statfile, statstr)
      logstr += '\nStatistics file _frequency_'+base+'.txt'+' written\n'
    } catch (err) {
      console.error(err)
    }
    
    htmlfile='./'+outdir+'/ '+base+'.html';
    writeHTML(htmlfile);
    logstr += 'HTML '+htmlfile+' written\n';

  } // end loop over all answers
  
  logfile='./'+'_log_'+ process.argv[2];
  try {
    const logdata = fs.writeFileSync(logfile, logstr);
    currentDate = new Date();    
    date = currentDate.getDate();
    time = currentDate.toTimeString();
    console.log(time+": msvg run completed. Logfile _log_"+process.argv[2]+" written.");
  } catch (err) {
    console.error(err)
  }
  
         
  //END of MSVG MAIN CODE  

   // AUX FUNCTIONS FOR CDE EXTRACTION
   
   // extractCDE: read a CDE text file line by line and store tab separated fields in 2D array
   // then, for each answer field, create dir and write names and SMILES answer into text file 
   // zz_XXXX.txt inside dir

    function extractCDE(cdefile) {

//       var infile='';
      let outfile='';
      let outstr='';
      let stats;
      let lines=[];
      let lf=[];
      const af=[];
      let name='';
      const pick=0;
      let numans=0;
//       var ans=[];
      let i=0;
      let j=0;

      if (fs.existsSync(cdefile)) {
        stats = fs.statSync(cdefile);
        if (!stats.isFile()) {
          console.log(cdefile+' is not a plain file!');
          return;
        }
      } else {
         console.log('extraxtCDE: input file '+cdefile+' not found!');
         return;
      }

      lines = fs.readFileSync(cdefile).toString().split("\n");
      console.log("The CDE file contains "+(lines.length-3)+" candidates");
      for(i=0;i<lines.length;i++) {
      //     console.log((i+1)+": "+lines[i]);
          lf=lines[i].split('\t'); // lf[] is array containing all fileds of a row (candidate)
          name=lf[0]+" "+lf[1]; // join the family and first names in name
          if (name!==undefined) {
      //       console.log('line '+i+" name= "+name);
            af.push(lf); // af is 2D array containing all fileds: af[row][column]
          }    
      }
      numans=af[0].length; //the number of fields in row 0
      console.log("The CDE file contains "+(numans-3)+" SMILES questions");
//       console.log('number of columns: '+numans);
      for (i=3; i < numans; i++) { // first line with question names: replace spaces in fields by underscore
        ans[i]=af[0][i].replace(/\s+/g,'_');
      }
      checkForMultiples();      

      for (i=3; i < numans; i++) { // extract all columns containing answers
      //extract and write to outstr
        if ((ans[i]==='') || (ans[i]===undefined) || (ans[i]==='na')) {
          continue;
        }
        outstr=''; // will contain one line (name, first name, answer) for one candidate for a particular SMILES question (column)
        for (j=0;j<af.length;j++) { // do for each name (row)
          if ((af[j][0] !== undefined) && (af[j][0]!=='')) {
            name=af[j][0]+"_"+af[j][1]+" ("+String(af[j][2])+")"; // join the family and first name fields and course in name 
            outstr += name+'\t'+af[j][i]+'\n';
          }
        }
        // create directory for this answer
        outdir=(path.basename(infile).substr(0, path.basename(infile).lastIndexOf('.')) || path.basename(infile))+'_'+ans[i];
        if (!fs.existsSync(outdir)){
          fs.mkdirSync(outdir);
          outdirlist.push(outdir);
        }
        // create SVGs subdirectory
        if (!fs.existsSync(outdir+'/SVGs')){
          fs.mkdirSync(outdir+'/SVGs');
        }
        // outfile is the zz_XXXX_CDE_Antwort_y.txt file containing the name and answer for each candidate for this SMILES-answer 
        outfile = './'+outdir+'/zz_'+(path.basename(infile).substr(0, path.basename(infile).lastIndexOf('.')) || path.basename(infile))+'_'+ans[i]+'.txt';
        // write to outfile
        try {
          const data = fs.writeFileSync(outfile, outstr) // write outstr to outfile
//           console.log("file "+outfile+" written");
        } catch (err) {
          console.error(err)
        }
      }
      
      // auxiliary function to extractCDE()
      
      function checkForMultiples() {
        let anu=0;
        let sco=0;
        let ro=0;
        let co=0;
        let nam='';
        let allsmc = [];
        let doubles = [];
        let doubans=[];
      
        for (ro=0; ro < af.length;ro++) { // for all candidates
          allsmc=[];
          doubles=[];
          nam=af[ro][0]+'_'+af[ro][1];
          for (co=3; co < numans; co++) {
            allsmc.push(af[ro][co]);
          }
          for (sco=0; sco < allsmc.length; sco++) { 
            if ((allsmc[sco]!==undefined) && (allsmc[sco] !== 'leer') && (!allsmc[sco].includes('%')) && (!allsmc[sco].includes('na')) && (getOccurrence(allsmc,allsmc[sco]) > 1)) {
              if (!doubles.includes(allsmc[sco])) {
                doubles.push(allsmc[sco]);
              }
            }
          }
          for (sco=0; sco < doubles.length; sco++) {
            doubans=[];
            for (anu=3; anu < af[0].length;anu++) { //register the answers with identical SMILES
              if (af[ro][anu]===doubles[sco]) {
                doubans.push(af[0][anu]);
              }
            }
            logstr += nam+' answered '+doubans.join(' and ')+' with SMILES '+doubles[sco]+'\n';
          }
          
        }
      }
      
      function getOccurrence(array, value) {
        let count = 0;
        array.forEach((v) => (v === value && count++));
        return count;
      }
      
    } // extractCDE end
    
    function writeHTML(hfile) {
      let i=0;
      let hstr='';
      const fontsize=11;
      let ncol=10;
      
      hstr += '<!DOCTYPE html>\n<html>\n<head>\n<meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0">\n';
      hstr += '<style>\n';
      hstr += '\t.row {\n';
      hstr += '\t\tdisplay: inline-flex;\n';
      hstr += '\t\tflex-wrap: wrap;\n';
      hstr += '\t\toverflow-y: auto;\n';
      hstr += '\t\t.svg {\n';
      hstr += '\t\t\tflow-root;\n';
      hstr += '\t\t}\n';
      hstr += '\t}\n';
      
      hstr += '\t.el {\n';
      hstr += '\t\tdisplay: block;\n';
      hstr += '\t\talign-self: auto;\n';
      hstr += '\t\tborder: 1px solid red;\n';
      hstr += '\t\tmargin: 2px;\n';
      hstr += '\t}\n';
            
      hstr += '\t.smtxt {\n';
      hstr += '\t\twidth: auto;\n';
      hstr += '\t\tfont-size: '+String(fontsize)+'px;\n';
      hstr += '\t}\n';
      
      hstr += '\t.nam {\n';
      hstr += '\t\tfont-family: Arial, Helvetica, sans-serif;\n';
      hstr += '\t\tfont-size: '+'14px;\n';
      hstr += '\t\tcolor: blue;\n';
      hstr += '\t}\n';

      hstr += '\t.title {\n';
      hstr += '\t\ttext-align: center; font-family: Arial, Helvetica, sans-serif; font-size: 18px;\n';
      hstr += '\t}\n';
      hstr += '</style>\n';

      hstr += '<div class="title">\n<h3>'+base+': Nicht automatisch bewertete SMILES Antworten</h3>\n</div>\n';
      hstr += '<div class="row">\n'; 
      for (i=0; i < svglist.length;i++) {
        hstr += '<div class="el">\n';
        hstr += '\t<div class="nam">\n'+namelist[i]+'</div><br>\n';
        hstr += '\t<object class="svg" data="'+svglist[i]+'" type="image/svg+xml"></object><br>\n';
        ncol = Math.round(cellW/6.8);
        hstr += '<textarea class="smtxt" readonly cols="'+ncol+'" wrap="soft|hard">'+smlist[i]+'</textarea>\n';
        hstr += '</div>\n';
      }
      hstr += '</div>\n';
      hstr += '</body>\n';
      
      try {
        const data = fs.writeFileSync(hfile, hstr)
      } catch (err) {
        console.error(err)
      }      
    }
    
//END msvg FRAME
