//START MOSTEST FRAME
// mostest_210424.js
//
// javascript code for testing mosfeccs with a series of SMILES from a textfile (UTF8 tab separated).
// INPUT: a xxx.txt file with a header, comment lines (#) and
//        data lines in format "^molcode\tSMILES\n", one per SMILES to be tested
//        molcode must have the format xx.yyy which is translated into the svg-filename as 00000 filled xxxyyy
//        example: molcode 9.32 will translate into filename 09032.svg
//        this file must reside inside the current directory
// OUTPUT:
// The current folder will contain:
// 1. a LOG file showing Title, timestamp, comments as copied from input file, molcode, OK | parser failure message | ERROR message
// 
// 2. A subfolder "SVGs", containing all graphics files for the structural formulae in .svg format
//    The .svg graphics files inside the "SVGs" folders are generated by the parser of MOSFECCS_v5
//    and checked for identity with the input SMILES by getsmiles() of of MOSFECCS_v5


// USAGE:
//  Note: nodeJS must be installed on your Mac for this: check in terminal by entering: which node<return>. If empty string is returned, 
//  install nodeJS from: https://nodejs.org/en/
// 
//  In the terminal: Use cd to go to the directory containing the input xxx.text file and this script (mostest_xxxxxx.js)
//  In the terminal, enter: node mostest_xxxxxx.js xxx.txt<return>

// NOTE: depending on the number of SMILES, execution of this script may require several seconds.

// December 2019 copyright B. Jaun, ETH Zurich

// MODIFICATIONS:
// 200108: DQM BUGFIX included
// 200201.1 all BUGFIXES up to 200130.4 included
// 200210: all BUGFIXES up to 200209.1 included
// 200215: new drawAtomLabel_svg()
// 200225: lebab let, arrow, arrow-return transforms done
// 200226: closure compiler ADVANCED gives no error and only warnings related to externs
//         functions xxxx_svg() are particular to mostest,all others are identical to mv5_200225.js
// 200301: new ordering of functions into MV5/MOSTEST-COMMON and MOSTEST-SPECIFIC parts
//         lebab transforms let_>arrow->arrow-return->includes done for all MOSFECCS specific parts.
//         reassembly of MOSTEST to make mostest-200301.js from the MV5/MOSTES-COMMON functions of mv5_200301.js 
//         and the new MOSFECCS-SPECIFIC block.
//         closure compiler ADVANCED gives no error and only 6 warnings related to externs        
//         Tested with BJ_testMols_200216.txt.
// 201203: v6, redesign of sketcherframe, adaption to phones and MoodleMobileApp

    "use strict";
    
// externs for compiler ADVANCED

// function  require(txt) {}; //for acc only
// /**
//  * @constructor
//  * @extends events.EventEmitter
//  */
// var process = function() {};
// /**
//  * @type {Array.<string>}
//  */
// process.argv;
// /**
//  * @return {string}
//  */
// process.cwd = function() {};
// /**
//  * @type {Object.<string,string>}
//  */
// process.env;

  // MAIN mostest FUNCTION (IIFE)
  (function mostest() {
    const fs = require('fs');
    const path = require('path');
    const readline = require('readline');
    
    
    // variables for mostest specific part
    let svgwidth=[];
    let stats;
    let infile='';
    let outfile='';
    let outstr='';
    const header = [];
    let lf = [];
    let lineNr='';
    let asmiles='';
    let molco='';
    let mc=[];
    let name='';
    let resu=0;
    let parserr='';
    let pWarnAtoms=[];
    const smfail=[];
    const smfailcheck=[];
    const mcfail=[];
    const a100=0;
    let aok=0;
    const smwarn=[];
    const mcwarn=[];
    const aerr=0;
    const smerr=[];
    const mcerr=[];
    const msgerr=[];
    let svg='';
    const i=0;
    const ii=0;
    const k=0;
    const j=0;
    let currentDate = new Date();
    let date = currentDate.getDate();
    const month = currentDate.getMonth(); 
    const year = currentDate.getFullYear(); 
    let time = currentDate.toTimeString();
    let logstr = '';
    let logfile = '';
    let commstr ='';
    const username = process.env.USER;
    const cwd = process.cwd();
    const cellW = 300;
    const cellH = 195;
    let errMsg = '';
    
  // variables from MOSFECCS_v6 drawCanvas() part    
  // pseudoconstants
        const version = "2104243";
        const build = "210421.1";
        const emfuSmiles = true;  // use small letters for atoms in mancude rings for SMILES.

        //graphics constants      
        // not dependent on bondlength
        const dbratio = 24; // distance between lines of double bond expressed as ratio bondlength/distance
        const charW = 11;  // used to calculate length of text in px
        let charH = 10; // used to set font size and calculate height of text in px
        const charWs = 11;  // used to calculate length of text in px
        const charHs = 14; // used to set font size and calculate height of text in px
        const pdx=10; // padding between canvas and mrect
        let bondlength = 30;  // length of a bond in px. !! Can be changed by parse SMILES when structure is larger than arect
      
        // dependent on bondlength
        let crit = bondlength/5;  // critical distance for mouse from atoms
        let ofs = Math.round(150*bondlength/dbratio)/100;  // distance between lines of double bond in px
        let downlw = 6*ofs;  // linewidth for dashed wedges
        let stdlw = (bondlength > 30)? 2:1.5;  // linewidth of a single bond in px

        // chemical constants
        //  regexp for matching valid element symbols
        const resreg = /^R[1234]?$/g; // pattern characterizing allowed residue symbols R,R1,R2,R3,R4
        const residues = ["R","R1","R2","R3","R4"]; //allowed residue symbols R,R1,R2,R3,R4
        const sextets = ["C:","N:"]; // carbenes and nitrenes
        //  array of all element symbols as strings
        const elesym = ["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu"];
        //  normal valency of all elements in elesym[]. 0 stands for no normal valency defined
        const val = [0,1,0,0,0,3,4,3,2,1,0,0,0,3,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,3,2,1,0,1,2,0,0,0,0,0,0,0,0,1,2,3,4,3,2,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        const elpos = ["B","Al"]; // electropositive elements with hydride ligands
        const prim = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
              101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,
              233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,
              383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,
              547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,
              701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,
              877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013 ,1019,1021,1031,
              1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,
              1181,1187,1193,1201,1213,1217]; // primes from 1->2 to 200->1217
        const organic = ["B", "C", "N", "O", "P", "S", "F", "Cl", "Br", "I","Si"]; // the elements considered to be "organic"
        const emfuAtoms = ["B","C", "N", "O", "P", "S", "As", "Se"]; // elements that can be part of an EMFU-ring
        const emfuElesym = ["b","c", "n", "o", "p", "s", "as", "se"]; // symbol of emfu-Element in SMILES
        // strings characterizing the bonding situations for each element that is considered as possible stereogenic center. format: "ElementSymbol:number of ligands:number of implicit hydrogens:charge"
        const pSC = ["C:4:0:0","C:3:1:0","Si:4:0:0","Si:3:1:0","Ge:4:0:0","Ge:3:1:0","Sn:4:0:0","Sn:3:1:0","N:4:0:1","P:4:0:1","B:4:0:-1","B:3:1:-1","P:4:0:0","As:4:0:1","N:3:0:az","P:3:0:0","As:3:0:0","P:2:1:0","As:2:1:0","S:4:0:0","S:4:0:1","S:3:0:0","S:3:0:1","Se:4:0:0","Se:4:0:1","Se:3:0:0","Se:3:0:1"];
        // strings characterizing the bonding situation of potentially stereogenic (trigonal pyramidal) three-valent centers
        const pyrSC = ["N:3:0:az","P:3:0:0","P:2:1:0","As:3:0:0","As:2:1:0","S:3:0:0","S:3:0:1","Se:3:0:0","Se:3:0:1"]; // no implicit H at pyramidal stereocenters allowed

  // variables with "global" scope inside drawCanvas()

        // rectangles defining areas on canvas
        const arect = new Rect(0,0,1000,1000); // the drawing area as a rect
        let gb = new Rect(0,0,0,0);  // rect to contain the bounding rectangle of a drawn object (structure or tree)

        // MAIN DATA STRUCTURES
        // arrays of Atom objects
        const m = [new Atom(0, "", 0, 0, 0, 0, 0)]; // index 0 contains a dummy atom, the real atoms start with m[1]
        const m_s = [new Atom(0, "", 0, 0, 0, 0, 0)]; // shadow copy of m for smiles calculation (without explicit H), filled by genshadow()
        const m_s0 = [new Atom(0, "", 0, 0, 0, 0, 0)]; // temporary copy of m_s for ring detection via hidebond(), filled by genshadow()
        const m_st = [new Atom(0, "", 0, 0, 0, 0, 0)];  // temporary copy of m_s for substructure (tree) determination,filled by genshadow()
        let m4cc = [new Atom(0, "", 0, 0, 0, 0, 0)];  // used for storing cumulenes in get_ccSense_one(), reset in clearMol(), filled by genshadow()
      
        // arrays of Bond objects
        const b = [new Bond(0,0,0)]; // index 0 contains a dummy bond, the real bonds start with b[1]
        const b_s = [new Bond(0,0,0)]; // shadow copy of m for smiles calculation (without explicit H) filled by genshadow()
        const b_s0 = [new Bond(0,0,0)]; // temporary copy of b_s for ring detection via hidebond() filled by genshadow()
        const b_st = [new Bond(0,0,0)]; // temporary copy of b_s for substructure (tree) determination filled by genshadow()
      
        // other arrays of data objects
        let lig = [new Branch(0,0)];
        let arro = []; //array storing the Arrow{} objects
        let arro_s = []; //shadow array of arrows for SMILES
        let rxnarro = []; // array storing Rxnarw{} objects
        let rxn_s = []; // shadow array of rxn arrows for SMILES
      
        // primitive variables used in SMILES Input und conversion
      
        //arrays used by functions in several sections: have to be in the drawCanvas scope
        let bisectors = []; // array containing the directions in Â° of the bisectors between all bonds at an atom //BF191115
        let bridgeheads = []; // array with atom indices of bridgeheads. Filled by findBridgeheads() !!used also by stereobonds()
        let ccSense = []; // pseudohash: key is string with atom index of central atom, value is @ or @@
        let cumulat = []; // array with the atom indices of all cumulene atoms  !! used in getsmiles() and parseSMILES()
        let ezCC = []; // array of cumulene objects containing even cumulenes !!used also by parseSMILES()
        let incoming = []; // array specifiying for each atom the "incoming" atom. index is parallel to m[]. Filled by dfsRC !!used also by flipBranch()
        let mol_brects = []; // the bounding rects of all molecules
        let molgrp_brects = []; // the bounding rects of molgrps
        let pscCC = []; // array of potentially stereogenic cumulenes !!used also in smiles parsing
        let rcstr = []; // hash with the atom index as key and the ring closures string as value. Filled by dfsRC() !! used also by smiles parsing
        let ringatoms = []; // array containing atom indices off all atoms in rings. Filled by findRingBonds() !!used also in smiles parsing
        let ringbonds = []; // array of indices in b-type arrays. Filled in findRingBonds(), required by isSCcandidate,!! used by several sections
        let ringclosures = []; // array of strings xx:yy with xx and yy being atom indices of atoms in ring closure !!used by several sections
        let rings = [];  // 2D array. rings[ringnumber][index in ring]. Values are the atom indices !!used by several sections
        let sectors = []; // array of Sector{} objects containing the sectors between bonds around an atom !! used in several sections
        let smilesarray = []; // array of atom indices in the order from dfsSmiles !! used in several sections
        let visnodesDFS = []; // array of the nodes visited by dfs(). Values are atom indices !!used by several sections
        let warnAtoms = []; //!!used in getsmiles and parseSMILES: the atoms that will be shown with a red square
      
        // primitive variables
        let nmol = 0; // number of molecules (trees)
        let nRings = 0; // the number of rings. Calculated from the number of bonding partners of each atom by numRings()

      
         //variables required to remember things from one mouse event to the next one
        let permstodo = 1; // counter for permutations remaining to be done
        let permu = 1; // total permutations due to ties
        let rxnco = [];
        let smiles = "";  // the SMILES string

        // boolean variables and flags
        // alternators for provisional drawing      
        let hasStereo = false;
        let nolinedash = false;  // indicator for browsers that do not support linedash
      
        // types (groups) of tools and elements

        // variables for compatibility with mv5_xxx.js functions
        let showatnum = false; // flag used in diagnostic
        let showsymnum = false; // flag used in diagnostic
        let benzene = false; 

  // END of variable declarations

// MAIN CODE OF mostest()

  console.log(intLeadingZero(date,2)+"." + intLeadingZero(month + 1,2) + "." + year+" "+time);
  console.log("mostest.js run with txt file: "+process.argv[2]);
  logstr += "LOGFILE for run of "+process.argv[1]+" with file: "+process.argv[2]+"\n";
  logstr += "run by "+username+" on node at ";
  logstr += intLeadingZero(date,2)+"." + intLeadingZero(month + 1,2) + "." + year+" "+time+"\n";
  logstr += "=========================================\n";  
// Input: text file 
  // Make sure we got a filename on the command line.
  if (process.argv.length === 3) {
    infile = process.argv[2];
    if (fs.existsSync(infile)) {
      stats = fs.statSync(infile);
      if (!stats.isFile()) {
        console.log(infile+' is not a plain file!');
        return;
      }
    } else {
       console.log('input file '+infile+' not found!');
       return;
    }
  } else {
    console.log('Usage: node ' + process.argv[1] + ' <text filename>');
    return;
  }

  infile = './'+infile;
  const readInterface = readline.createInterface({
    input: fs.createReadStream(infile),
    console: true
  });
  
  if (!fs.existsSync('./SVGs')){
    fs.mkdirSync('./SVGs');
  }

  
  readInterface.on('line', line => {
    procline(line);
  });
  
  readInterface.on('close', line => {
    finish();
  });

  lineNr = 0;
  
  function procline(lin) {
    lineNr++;
    if (lineNr===1) {
      return;
    } else if (/^#/.test(lin)) {
      commstr += lin+"\n";
      lineNr--;
    } else {
      svg='';
      molco='';
      name='';
      mc=[];

      svgwidth = [];
      lf = [];
      
      lf=lin.split('\t');
      if (lf[0]!==undefined) { 
        molco = String(lf[0]);       
        name=molco; // use mol code as identifier and filename of SVGs
      } else {
        console.log("lineNr "+lineNr+" Error: molco undefined. line:"+lin);
        return;
      }
      if (lf[1]!==undefined) {
        asmiles=lf[1].trim();
      } else {
        console.log("lineNr "+lineNr+" Error: asmiles undefined. line:"+lin);
        return;
      }
      parserr = '';
      try {
        resu=parse_m_SMILES_svg(asmiles); 
      }
      catch(err) { //errors caused in parse_m_SMILES by JS
        console.error(err);
        errMsg = 'error caught by JS: '+err;
        resu=-3;
      }
      if (parserr !== '') { //Error in parse_m_SMILES or parseSMILES()
        errMsg = parserr;
        resu = -3;
      }
      if ((resu===0) || (resu===-1)) { // OK or parseSMILES failure
        clearMol_svg();
        outfile = './SVGs/'+molco+'.svg';
        
        try {
          const data = fs.writeFileSync(outfile, svg)            
        } catch (err) {
          console.error(err)
        }
        if (resu===0) {
          logstr += molco+" OK\n";
          aok++;
        } else if (resu===-1) {
          logstr += molco+" parsing failed for SMILES: "+(asmiles.trim())+" checkSMILES: "+smfailcheck.slice(-1)[0]+"\n";
          smfail.push(asmiles);
//           smfailcheck.push(smiles);
          mcfail.push(molco);
        }
      } else if (resu===-2) { //Warning atoms
        smwarn.push(asmiles);
        mcwarn.push(molco);
        console.log("mol:"+molco+" Parsing led to warnAtoms! SMILES: "+asmiles);
        logstr += molco+" Parsing led to warnAtoms! SMILES: "+asmiles+"\n";
        clearMol_svg();
      } else if (resu===-3) {
        smerr.push(asmiles);
        mcerr.push(molco);
        msgerr.push(parserr);
        console.log("mol:"+molco+" Parser ERROR for SMILES: "+asmiles);
        console.log("\tERR: "+errMsg);
        logstr += molco+" Parser ERROR for SMILES: "+asmiles+"\n";
        logstr += "\tERR: "+errMsg+"\n";
        clearMol_svg();
      }
    }
  } // end function procline  
  
  function finish() {
    let i=0;

// write the LOG-file    
    logfile='./'+'LOG_'+ process.argv[2];
    try {
      const logdata = fs.writeFileSync(logfile, logstr);
      currentDate = new Date();    
      date = currentDate.getDate();
      time = currentDate.toTimeString();
      console.log(time+': '+process.argv[1]+' run completed\nFiles SUMMARY_'+process.argv[2]+' and LOG_'+process.argv[2]+' written.');
    } catch (err) {
      console.error(err)
    }

//write the SUMMARY file
    outfile='./'+'SUMMARY_'+ process.argv[2];
    
    outstr = 'SUMMARY for run of '+process.argv[1]+' with file '+process.argv[2]+'\n';
    if (commstr !== '') {

      outstr += 'Comments:\n'+commstr+'\n';
    }
    if (aok > 0) {
      outstr += aok+' of a total of '+(lineNr-1)+' SMILES passed the test.\n\n';
    }  
    if (smerr.length > 0) {
      outstr += 'PARSER ERRORS:'+smerr.length+'\n';
      for (i=0; i < smerr.length;i++) {
        outstr += mcerr[i]+': '+smerr[i]+' Error:'+msgerr[i]+'\n';
      }
    }
    if (smwarn.length > 0) {
      outstr += 'ATOM WARNINGS:'+smwarn.length+'\n';
      for (i=0; i < smwarn.length;i++) {
        outstr += mcwarn[i]+': '+smwarn[i]+"\n";
      }
    }
    if (smfail.length > 0) {
      outstr += '\nPARSER FAILURES:'+smfail.length+'\n\n';
      for (i=0; i < smfail.length;i++) {
        outstr += mcfail[i]+' SMILES entered:\n'+(smfail[i].trim())+'\n'+smfailcheck[i]+'\nwas returned by getsmiles() of parsed structure\n\n';
      }    
    }
    try {
      const outdata = fs.writeFileSync(outfile, outstr);
    } catch (err) {
      console.error(err)
    }

  }  
         
  //END of MOSTEST MAIN CODE  

//END MOSTEST FRAME
